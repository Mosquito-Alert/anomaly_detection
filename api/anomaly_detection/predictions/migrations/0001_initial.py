# Generated by Django 5.2 on 2025-05-14 10:26

import django.contrib.postgres.fields
import django.db.models.deletion
import django.db.models.expressions
import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('geo', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='MetricExecution',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date', models.DateField(help_text='The date of the execution.', unique=True, verbose_name='Date')),
                ('success_percentage', models.FloatField(help_text='The percentage of success of the execution.', verbose_name='Success percentage')),
            ],
            options={
                'verbose_name': 'Metric Execution',
                'verbose_name_plural': 'Metric Executions',
                'ordering': ['date'],
                'indexes': [models.Index(fields=['-date'], name='predictions_date_f6ae64_idx')],
            },
        ),
        migrations.CreateModel(
            name='Predictor',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('trained_at', models.DateTimeField(help_text='The specified date in which the model was trained.', verbose_name='Trained at')),
                ('weights', models.JSONField(blank=True, help_text='The predictor model itself.', null=True, verbose_name='Weights')),
                ('seasonality', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(), blank=True, help_text='The predicted seasonality for the metric.', null=True, size=365, verbose_name='Seasonality')),
                ('trend', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(), blank=True, help_text='The predicted serial tendency for the metric.', null=True, size=None, verbose_name='Trend')),
                ('region', models.ForeignKey(help_text='The region associated to the predictor.', on_delete=django.db.models.deletion.CASCADE, related_name='predictors', to='geo.municipality', verbose_name='Region')),
            ],
            options={
                'verbose_name': 'Predictor',
                'verbose_name_plural': 'Predictors',
                'ordering': ['region', '-trained_at'],
            },
        ),
        migrations.CreateModel(
            name='Metric',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date', models.DateField(help_text='The date of the metric.', verbose_name='Date')),
                ('value', models.FloatField(help_text='The actual value of the metric.', verbose_name='Value')),
                ('predicted_value', models.FloatField(blank=True, help_text='The predicted value of the metric. This value will be estimated at creation.', null=True, verbose_name='Predicted value')),
                ('lower_value', models.FloatField(blank=True, help_text='The predicted lower band value of the metric, from which values will be             considerated as anomalies. This value will be estimated at creation.', null=True, verbose_name='Lower value')),
                ('upper_value', models.FloatField(blank=True, help_text='The predicted upper band value of the metric, from which values will be             considerated as anomalies. This value will be estimated at creation.', null=True, verbose_name='Lower value')),
                ('anomaly_degree', models.GeneratedField(db_persist=True, expression=models.Case(models.When(then=django.db.models.expressions.CombinedExpression(django.db.models.expressions.CombinedExpression(models.F('value'), '-', models.F('upper_value')), '/', models.F('value')), value__gt=models.F('upper_value')), models.When(then=django.db.models.expressions.CombinedExpression(django.db.models.expressions.CombinedExpression(models.F('value'), '-', models.F('lower_value')), '/', models.F('value')), value__lt=models.F('lower_value')), default=models.Value(0.0), output_field=models.FloatField()), help_text='The degree of the anomaly, a range of values that starts on -1 (a lower anomaly of the             highest degree) and ends on +1 (a upper anomaly of the highest degree). The 0 value means that             these is no anomaly. This value will be estimated at creation.', null=True, output_field=models.FloatField(), verbose_name='Anomaly degree')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('region', models.ForeignKey(help_text='The region associated to the metric.', on_delete=django.db.models.deletion.CASCADE, related_name='metrics', to='geo.municipality', verbose_name='Region')),
                ('predictor', models.ForeignKey(blank=True, help_text='The predictor which has the model and the predicted values associaded to the metric.', null=True, on_delete=django.db.models.deletion.RESTRICT, related_name='metrics', to='predictions.predictor', verbose_name='Predictor')),
            ],
            options={
                'verbose_name': 'Metric',
                'verbose_name_plural': 'Metrics',
                'ordering': ['region', '-date'],
            },
        ),
        migrations.AddIndex(
            model_name='predictor',
            index=models.Index(fields=['region', 'trained_at'], name='predictions_region__c214a5_idx'),
        ),
        migrations.AddConstraint(
            model_name='predictor',
            constraint=models.UniqueConstraint(fields=('region', 'trained_at'), name='unique_predictor'),
        ),
        migrations.AddIndex(
            model_name='metric',
            index=models.Index(fields=['date'], name='predictions_date_6dc93c_idx'),
        ),
        migrations.AddIndex(
            model_name='metric',
            index=models.Index(fields=['region', 'date'], name='predictions_region__c7e563_idx'),
        ),
        migrations.AddConstraint(
            model_name='metric',
            constraint=models.UniqueConstraint(fields=('region', 'date'), name='unique_metric'),
        ),
    ]
